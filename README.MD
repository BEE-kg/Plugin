# Отчёт о проделанной работе

## Общие сведения

- **Автор**: *Голованов Кирилл Антонович*

- **Группа**: *М3107*

- **Название плагина**: *Трекер времени работы/отдыха*

## Анализ плагина

- **Язык плагина**: *python*

- **Среда разработки**: *Visual Studio Code*

- **Функционал плагина**:

    - открытие/закрытие через комбинации клавиш

    - счет времени работы пользователя
    
    - отправка уведомлений windows по истечении определенного времени о необходимости отдыха

    - постановка трекера на паузу и снятие с нее

    - запись всех событий в файл текущего проекта и отображение их же в стандартный поток вывода/ввода

    - отдельный интерфейс трекера

## Подробный разбор согласно функционалу

### Импортируемые библиотеки

- **time** - для счёта времени

- **random** - для рандома фраз в уведомлениях

- **tkinter** - для создание интерфейса

- **plyer** - для создания уведомлений

- **keyboard** - контроля за комбинациями

- **pytz** - для работы с конкретной временной зоной

- **datetime** - для получения текущего времени

### Комбинации клавиш

#### Запуск плагина

Для запуска файла требуется зайти в терминал вывода/ввода, после чего будет достаточно ввести комбинацию клавиш: **ctrl+shift+t**. Так как эта комбинация прописана в пользовательских настройках горячих клавиш системы, то она вызывает наш плагин для дальнейшей работы. Сам .json-файл, где это прописано, выглядит так:

```json
{
    "key": "ctrl+shift+t",
    "command": "workbench.action.terminal.sendSequence",
    "args": {
        "text": "python C:/Study/ISRPO/Plugin_lab/timer.py\n"
    }
}    
```

Поле **key** отвечает за саму комбинацию, поле **command** - за то, где должна вызваться данная команда, а **args** - за то, что должно быть выведено после нажатия.

#### Прекращение работы плагина

Для прекращения работы уже в теле плагина предусмотрена отдельная функция, которая анализирует, была ли введена соответствующая команда выхода **ctrl+shift+1**. Вот код, где это прописано:

```python
keyboard.add_hotkey('ctrl+shift+1', lambda: quit_program(window))

def quit_program(window):
    print("Программа завершена по комбинации клавиш Ctrl + Shift + 1.")
    log_break("stop")
    window.destroy()
    exit()
```

### Счёт времени

Счёт времени реализован в отдельной функции, где проверяется проверка на паузу, вычисление времени работы, обновление отображаемого времени, проверка времени для напоминания и рекурсивный вызов (чтобы это был именно трекер). Таким образом, функция отвечает за отслеживание времени, отображение его на экране и создание напоминаний о перерывах. Сама функция:

```python
def update_timer(label, reminder_interval, window):
    global start_time, is_paused
    if not is_paused:
        current_time = int(time.time() - start_time)
        label.config(text=f"Прошло времени: {current_time} секунд")
        if current_time >= reminder_interval:
            label.config(text="Пора сделать перерыв!")
            log_break("break", current_time)
            notification.notify(
                title="Пора сделать перерыв!",
                message=get_random_message(),
                timeout=10
            )
            start_time = time.time()

    label.after(1000, update_timer, label, reminder_interval, window)
```

### Отправка уведомлений

Сами по себе уведомления уникальны - их порядка 16 штук. Из них рандомным образом выбирается одно - именно оно отправится пользователю с предложением сделать перерыв. Эта часть кода содержится в следующей функции:

```python
def get_random_message():
    messages = [
        "Пора сделать перерыв! Встань и разомнись.",
        "Напоминаем: время сделать паузу.",
        "Как насчет короткой прогулки или растяжки?",
        "Остановись, сделай вдох и выдох.",
        "Хорошая работа! Но время сделать перерыв.",
        "Подумай о здоровье: время размяться.",
        "Перерыв поможет сохранить продуктивность.",
        "Вдохни глубоко. Время на перерыв.",
        "Ты молодец! Но небольшая пауза не повредит.",
        "Работа важна, но отдых важнее.",
        "Перерыв — это инвестиция в энергию.",
        "Время растянуться или прогуляться.",
        "Напоминаем: здоровье превыше всего.",
        "Перерыв? Самое время сделать его.",
        "Усталость — сигнал к отдыху.",
        "Время освежить мысли перерывом!"
    ]
    return random.choice(messages)
```

Далее уведомления отправляются в систему пользователя через то тело кода, которое уже указано в предыдущем заголовке о подсчёте времени, а именно в специальном условии: 

```python
if current_time >= reminder_interval:
    label.config(text="Пора сделать перерыв!")
    log_break("break", current_time)
    notification.notify(
        title="Пора сделать перерыв!",
        message=get_random_message(),
        timeout=10
    )
    start_time = time.time()
```

Если наше время работы перешагивает порог, то выполняется это условие и, по итогу, пользователь получает сообщение.

### Пауза и возобновление

Обе команды представлены отдельными функциями, а также прописаны соответсвующами кнопками в пользовательском интерфейсе (об этом дальше). При функции паузы код продолжает работу, просто трекер времени статичен и сигнал единожды поступает в трекер-файл (о нем дальше) о запоминании события. Функция паузы:

```python
def toggle_pause():
    global is_paused, start_time, paused_time
    if not is_paused:
        is_paused = True
        paused_time = int(time.time() - start_time)
        log_break("pause")
```
При функции возобновления просто убирается флаг глобальной переменной и код продолжает счётчик времени с текущей остановки. Описания события также записывается в файл. Сама функция:

```python
def resume_timer():
    global is_paused, start_time, paused_time
    if is_paused:
        is_paused = False
        start_time = time.time() - paused_time
        log_break("resume")
        print("Таймер возобновлен.")
```

### Сбор статистики

#### Запись в отдельный файл

В плагине происходит сбор всей статистики по текущему **Московскому времени**, а именно: пауз, возобновлений, уведомлений, начала и завершений трекера. Это выглядит как добавление в файл той информации, которой нужны. При отсутствии такого файла - он создаётся. Так, есть функция для определения текущего Московского времени:

```python
def get_moscow_time():
    moscow_tz = pytz.timezone('Europe/Moscow')
    moscow_time = datetime.now(moscow_tz)
    return moscow_time.strftime("%Y-%m-%d %H:%M:%S")
```

Далее происходит запись всех событий в режиме реального времени в файл:

```python
def log_break(action, time_spent=None):
    moscow_time = get_moscow_time()
    with open("break_log.txt", "a") as log_file:
        if action == "break":
            log_file.write(f"Сделан перерыв в {moscow_time}. Всего прошло {time_spent} секунд работы.\n")
        elif action == "pause":
            log_file.write(f"Таймер поставлен на паузу в {moscow_time}.\n")
        elif action == "resume":
            log_file.write(f"Таймер возобновлен в {moscow_time}.\n")
        elif action == "stop":
            log_file.write(f"Программа завершена в {moscow_time}.\n")
```

#### Вызов статистики из интерфейса

При нажатии кнопки статистики в пользовательском интерфейсе, юзер получит текущий формат файла со сбором статистики. Он будет из себя представлять отдельное окно, однако при вызове этой команды, меняться оно на глазах у пользователя не будет, лишь исходный файл. Код этой функции:

```python
def show_statistics():
    try:
        with open("break_log.txt", "r") as log_file:
            stats = log_file.read()
            stats_window = tk.Toplevel()
            stats_window.title("Статистика")
            stats_label = tk.Label(stats_window, text=stats, font=("Arial", 12), justify="left")
            stats_label.pack(padx=10, pady=10)
    except FileNotFoundError:
        messagebox.showinfo("Статистика", "Файл статистики отсутствует.")
```

В функции сразу представлено то, как это окно будет выглядеть через GUI, несмотря на то, что это лишь следующий заголовок.

### GUI - интерфейс пользователя

Как таковой пользовательский интерфейс представлен в главной функции (в условии про использование GUI), несмотря на то, что там параллельно вызываются все базовые процессы плагина:

```python
def main(reminder_interval, use_gui):
    global start_time, is_paused, paused_time
    total_time = 0
    is_paused = False
    paused_time = 0
    print(f"Трекер времени запущен. Напоминания будут каждые {reminder_interval} секунд.")
    
    if use_gui:
        window = tk.Tk()
        window.title("Трекер времени")

        label = tk.Label(window, text="Прошло времени: 0 секунд", font=("Arial", 16))
        label.pack(padx=20, pady=20)

        start_time = time.time()

        update_timer(label, reminder_interval, window)

        pause_button = tk.Button(window, text="Пауза", font=("Arial", 14), command=toggle_pause)
        pause_button.pack(pady=5)

        resume_button = tk.Button(window, text="Возобновить", font=("Arial", 14), command=resume_timer)
        resume_button.pack(pady=5)

        stats_button = tk.Button(window, text="Показать статистику", font=("Arial", 14), command=show_statistics)
        stats_button.pack(pady=5)

        keyboard.add_hotkey('ctrl+shift+1', lambda: quit_program(window))

        window.mainloop()

    else:
        print("GUI отключен, запуск в консольном режиме невозможен.")
```

Также, как и сказано ранее, графический интерфейс представлен в другой функции вызова статистики.

## Примечание

### Последняя функция

Она нужна для того, чтобы вызывать весь основной код, однако в ней есть важная настройка **reminder_interval** - именно эта переменная отвечает за то, в какой интервал секунд программа будет присылать вам уведомление о необходимости отдыха. Потому при необходимости изменить интервал сообщений пользователь должен менять именно эту переменную.